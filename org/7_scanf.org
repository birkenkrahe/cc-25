#+TITLE:Formatted I/O: scanf
#+AUTHOR:Marcus Birkenkrahe
#+Source: KN King C Programming
#+SEQ_TODO: PRACTICE TODO NEXT | DONE
#+SUBTITLE:CSC 100 Introduction to programming in C/C++, Spring 2025
#+STARTUP: overview hideblocks indent entitiespretty
#+OPTIONS: toc:1 num:1 ^:nil
#+PROPERTY: header-args:C :main yes :includes <stdio.h>  :exports both
* README

- There is much more to ~scanf~ and ~printf~ than we've seen

- I/O is where the pedal hits the metal - where man meets machine

- In this notebook: conversion specifications for ~scanf~

- Practice workbooks, input files and PDF solution files in GitHub

* scanf

- A ~scanf~ *format string* may contain ordinary characters and conversion
  specifications like ~d~, ~e~, ~f~, ~g~

- The *conversions* allowed with ~scanf~ are essentially the same as those
  used with ~printf~

- The ~scanf~ format string tends to contain *only* conversion specs

* First example

- Example input:
  #+begin_example
  1  -20  .3   -4.0e3
  #+end_example

- Emacs: Create input file
  #+begin_src bash
    echo "1  -20 .3 -4.0e+3" > input  # store string in file`input`
    cat input  # view the file `input`
  #+end_src

  #+RESULTS:
  : 1  -20 .3 -4.0e+3

- Example program to read this input:
  #+name: pgm:tscanf
  #+begin_src C :cmdline < input :results output :tangle io.c
    int i, j;
    float x, y;

    scanf("%d%d%f%e", &i, &j, &x, &y);

    printf("|%5d|%5d|%5.1f|%10.1e|\n", i, j, x, y);
  #+end_src

  #+RESULTS: pgm:tscanf
  : |    1|  -20|  0.3|  -4.0e+03|

* Emacs VIPs only

- To run the code block above in a /new/ file, you need to add a couple
  of header arguments:
  #+begin_example
  :main yes :includes <stdio.h>
  #+end_example
  1) The first one wraps the code block into a =main= function
  2) The second one includes the input/output header file =stdio.h=

- Practice creating input on the shell yourself now:
  1) In Emacs, open a shell with ~M-x eshell~
  2) Put a string into a file on the shell, list it and print it:
     #+name: tab:shell
     | COMMAND                           | MEANING                          |
     |-----------------------------------+----------------------------------|
     | ~echo "hello there"~                | print ~hello there~ to the screen  |
     | ~echo "hello there" > hello~        | save "hello there" to file ~hello~ |
     | ~ls -l hello~                       | long listing of file ~hello~       |
     | ~cat hello~                         | print content of file ~hello~      |
     #+end_example

- If you entered the code block and tangled it, you now have a file
  ~io.c~ in the same directory as your Org-mode file: compile and run it.
  #+begin_src bash :results output
    ls -l io.c  # check the file is there
    gcc io.c -o io  # compile it and name the executable file io
    ls -l io  # check that the executable was created
    ./io < input  # run file with input file
  #+end_src

  #+RESULTS:
  : -rw-rw-r-- 1 marcus marcus 158 Feb 26 09:45 io.c
  : -rwxrwxr-x 1 marcus marcus 16056 Feb 26 13:04 io
  : |    1|  -20|  0.3|  -4.0e+03|

- The last command ~io < input~ will not work in =eshell= because
  /redirection/ (with =<=) is not supported. There may be a workaround:
  #+begin_src bash
    cat input | ./io  # directs output to stdout and pipes it into the file io
  #+end_src

  #+RESULTS:
  |   | 1 | -20 | 0.3 | -4000.0 |

- Note: the file ~io~ has to be run ~./io~ on Unix-type shells to let the
  computer know that the file is in the current (~.~) directory. On the
  Windows CMD line, ~io~ is sufficient.

* Main traps

- The compiler will not check that specs and variable input match up.

- The ~&~ pointer symbol must not miss in front of the input variable.

- ~scanf~ works in mysterious ways (we'll see why in a moment)

* How scanf works

- ~scanf~ is a pattern-matching function: it tries to match input groups
  with conversion specifications in the format string

- For each spec, it tries to locate an item in input

- It reads the item, and stops when it can't match

- If an item is not read successfully, ~scanf~ aborts

#+caption: How scanf works (Event-controlled Process Chain diagram)
#+attr_latex: :width 400px
[[../img/7_scanf.png]]

- Ignores white-space: space (~" "~), TAB (~\t~), new-line (~\n~)

- Input can be on one line or spread over several lines:
  #+attr_latex: :width 300px
  #+caption: Input file for scanf
  [[../img/7_input.png]]

- *Try this in OneCompiler.com now!*

- ~scanf~ sees a character stream (~¤~ = new-line, ~s~ = skip'd, ~r~ = read):

  #+begin_example
  ••1¤-20•••.3¤•••-4.0e3¤
  ssrsrrrsssrrssssrrrrrr
  #+end_example

  - When asked to read an *integer* (~%d~ or ~%i~), ~scanf~ searches for a
    digit, or a +/- sign, then reads until it encounters a non-digit

  - When asked to read a *float* (~%f~, ~%g~, ~%e~), ~scanf~ looks for +/- sign,
    digits, decimal point, or an exponent (~e+02~, ~e-02~)

  - When used with ~scanf~, ~%e~, ~%f~, ~%g~ are completely interchangeable
    (*try that in OneCompiler.com with the last format specifier*).

  - When it finds a character that cannot be part of the current item,
    the character is returned to be read again during the scanning of
    the next input item or the next call of ~scanf~.

* Walk through example

This example has the same spec as our earlier example:
~"%d%d%f%f",&i,&j&x&y~. This is what the computer "sees":
#+begin_example
  1-20.3-4.0e3¤
#+end_example

1) Expects ~%d~. Stores ~1~ in ~i~, returns ~-~

2) Expects ~%d~. Stores ~-20~ in ~j~, returns ~.~

3) Expects ~%f~. Stores ~0.3~ in ~x~, returns ~-~

4) Expects ~%f~. Stores ~-4.0 x 10^3~ in ~y~, returns ~¤~ and finishes.

* Ordinary characters in format strings

- ~scanf~ reads white-space until it reaches a symbol.

- When it reaches a symbol, it tries to match to next input.

- It now either continues processing or aborts.

- Example: input contains "1. 3.56 100 5 .1" - how to scan?
  #+begin_src C :cmdline < input2
    float x=2., y=8., z; // initial values
    int   i=10, j=20;

    scanf("%f%f%d%d%f", &x, &y, &i, &j, &z);
    printf("%.1f %.2f %d %d %.1f",  x,  y,  i,  j, z);
  #+end_src

  #+RESULTS:
  : 1.0 3.56 100 5 0.1

- To create the input file on the shell[fn:1]:
  #+begin_src bash
    echo "1. 3.56 100 5 .1" > input2
    cat ./input2
  #+end_src

  #+RESULTS:
  : 1. 3.56 100 5 .1

* Example with ordinary characters

- If the format string is ~"%d/%d"~ and the input is ~•5/•96~, ~scanf~
  succeeds: once the ~/~ is scanned, any number of white spaces are
  ignored.

- If the input is ~•5•/•96~ , ~scanf~ fails, because the ~/~ in the format
  string doesn’t match the space in the input: an ~/~ is expected
  immediately[fn:2].

- To allow spaces after the first number, use ~"%d•/%d"~ instead.

* Common mistakes:

1. Putting ~&~ in front of variables in a ~printf~ call
   #+begin_example C
    printf("%d %d\n", &i, &j);  /*** WRONG ***/
   #+end_example

2. Assuming that ~scanf~ should resemble ~printf~ formats
   #+begin_example C
    scanf("%d, %d", &i, &j);  // works only if input: `500, 400`
   #+end_example

   - After storing ~i~, ~scanf~ will try to match a comma with the
     next input character. If it's a space, it will abort.

   - For this example, only the input ~100, 100~ works, but not ~100 100~

3. Putting a ~\n~ character at the end of ~scanf~ string
   #+begin_example C
    scanf("%d\n", &i);
   #+end_example

   - To ~scanf~, the new-line is /white-space/. It will advance to the
     next white-space character and not finding one will hang forever

* PRACTICE Reading input with =scanf=

- You can open the exercises here on GitHub whenever you're lost.
  [[https://tinyurl.com/scanf-practice][tinyurl.com/scanf-practice]]

- We'll do these in class together and you will upload your results to
  Canvas (~"In-class practice 7: scanf"~).

- You will learn:
  + How to open a cloud command-line terminal (aka shell)
  + Create a new file with GNU =nano=
  + Save and rename files
  + Change and make directories
  + List, move, delete and rename files
  + Compile with changing the object file name
  + Create an input file with =echo=
  + Run an executable using a relative path
  + Open the editor and download a file
  + Compress files and upload archive files to Canvas

* Scan integer and floating-point input

1) Open a terminal.

2) Create a new file =scan1.c=.

3) Write the source code for a C program with input and output. Save
   at any point with =CTRL + s=.

4) Define two /integer/ variables ~k~, ~l~, and two /floating-point/ variables
   ~u~ and ~v~

5) Ask the user for input.

6) Complete the ~scanf~ /format string/ and enter the variables list to
   scan these variables

7) Save your file and compile it with =gcc= to check for syntax
   correctness. The standard executable is called =a.out=.

8) Run the executable using the relative path =./a.out= and enter the
   input by hand: ~100 -1000 .456 -9.34e2~

9) Alternatively, you can put the input into a file and redirect it to
   the executable. First create the input file:
   #+begin_src bash
     echo "100 -1000 .456 -9.34e2" > input1
     cat input1
   #+end_src

   #+RESULTS:
   : 100 -1000 .456 -9.34e2

10) Next, run the file using the =input1= file:
    #+begin_example sh
    ./a.out < input1
    #+end_example

11) Fix the =scanf= format until you get the desired output[fn:3]:
    #+name: pgm:scanf_out
    #+begin_example
     |  100|-1000|0.456| -934|
    #+end_example

12) Compile your file with =gcc= once more, and name the executable
    (object file) =scan1= with the command:
    #+begin_example sh
    gcc scan1.c -o scan1
    #+end_example

13) Run the file using the relative path to the file and the input
    data:
    #+begin_example
    ./scan1 < input1
    #+end_example

14) If everything works, download the file to your PC (~Open editor~,
    find the file in the sidebar, right-click to ~Download~).

15) Revisit all that you learnt before tackling the next one!
    #+begin_quote

|    | Concept/Action                       | Command/Code Example               |
|----+--------------------------------------+------------------------------------|
|  1 | Open a terminal                      | ~Open terminal~                      |
|  2 | Create a new file                    | =nano scan.c=                        |
|  3 | Compile with =gcc=                     | =gcc scan.c=                         |
|  4 | Relative file path                   | =ls ..=                              |
|  5 | Run executable with manual input     | =./a.out= <CR> 100                   |
|  6 | Create input file & view contents    | =echo "100" > input <CR> cat input=  |
|  7 | Run executable with redirected input | =./a.out < input=                    |
|  8 | Compile with specific output name    | =gcc scan.c -o scan=                 |
|  9 | Run named executable with input file | =./scanf < input=                    |
| 10 | Download the file to PC              | ~Open editor~ - ~Download~             |

    #+end_quote

=history= (commands), =ll= (long listing), =clear= (clean up), =*= (globbing).

* Scanning ordinary characters

1) Copy the previous program =scan1.c= into a new program =scan2.c= so
   that you don't have to rewrite all the code:
   #+begin_example sh
   cp -v scan1.c scan2.c
   ls scan*
   #+end_example

2) Now edit =scan2.c= using this code:
   #+name: pgm:ordTest1
   #+begin_src C :cmdline < ord1
     // variable declarations
     int i,j;

     // ask for keyboard input
     puts("Enter two integers separated by `/`:");

     // read keyboard input
     scanf("%d/%d",&i,&j);

     // print keyboard input
     printf("|%5d|%5d|\n",i,j);
   #+end_src

3) Compile the source code file and rename the object file to =scan2=:
   #+begin_example sh
   gcc scan2.c -o scan2
   #+end_example

4) Run the code block below with two inputs to compare:
   - ~•5/•96~ - this input should succeed
   - ~•5 /•96~ - this input should fail for the second number
   - ~•.5 /•96~ - this input should fail for both numbers

* Match input patterns exactly

This is useful for the programming exercise "phone numbers":

1) Copy the previous program =scan2.c= into a new program =scan3.c= so
   that you don't have to rewrite all the code.

2) Put the following into an input file =input3=: ~444==++//555~
   #+begin_example sh
   echo "444==++//555" > input3
   cat input3
   #+end_example

3) Delete the lines asking the user for input.

4) Make sure that the =scanf= command is formatted correctly to receive
   the input in =input3= and return the two integers with =printf=:
   #+begin_example sh
   The numbers were 444 and 555.
   #+end_example

5) Compile =scan3.c= and rename the object file to =scan3=.

6) Run the object file passing the input through =input3=
   #+begin_example sh
   ./scan3 < input3
   #+end_example

* Add fractions

1) Use the following command on the command-line shell to copy a
   template program from GitHub that you can then fill in:
   #+begin_src bash :results output :exports both
     wget -O scan4.c tinyurl.com/scan4-c
   #+end_src

2) Put the following *sample input* in an input file:
   #+begin_example
   5/6•
   3/4
   #+end_example

3) To do this, run this code on the command-line:
   #+begin_src bash :results output
     echo "5/6 " > input4
     echo "3/4"  >> input4
     cat input
   #+end_src

   #+RESULTS:
   : 5/6
   : 3/4

4) The *sample output* for the input 5/6 and 3/4 is:
   #+begin_example
   5/6 + 3/4 = 38/24
   #+end_example

5) The program prompts the user to add two fractions and then display
   their sum. Complete the format strings below so that the program
   runs as intended!
   #+name: pgm:addFrac
   #+begin_src C :cmdline < addFrac_input :results output :tangle ../src/scan4.c
     // declare variables
     int num1, denom1, num2, denom2, result_num, result_denom;

     // scan input
     scanf("...", &num1, &denom1);
     scanf("...", &num2, &denom2);

     // compute numerator and denominator
     result_num = num1 * denom2 + num2 *denom1;
     result_denom = denom1 * denom2;

     // print result
     printf("%d/%d + %d/%d = %d/%d\n",
            num1, denom1, num2, denom2,
            result_num, result_denom);
   #+end_src

6) Compile the program into an object file =scan4= and run it with =input4=:
   #+begin_example sh
   gcc scan4.c -o scan4
   ./scan4 < input4
   #+end_example

7) When you got the right results, copy =scan4.c= into =scan5.c= using =cp
   -v=. Open the file with =nano=, update the filename at the top, and
   modify the program so that there is only *on* ~scanf~ statement. Make
   sure that the modified program yields the same result as before.

* Submit results to Canvas

- At this point, you should have a bunch of =scan= and =input= files,
  including save files (=~=) and executables (object files):
  #+begin_example sh
    ls scan*.c input*
  #+end_example

  Output:
  #+begin_example
  input1  input4    scan2     scan2.cc~  scan3.cc  scan4.cc  scan5.cc  
  input3  scan1.cc  scan2.cc  scan3      scan4     scan5     scan5.cc~
  #+end_example

- Compress your source and input files into an archive file =scan.zip=
  (using the 'glob' character =*=):
  #+begin_example
  zip scan.zip scan1.c scan2.c scan3.c scan4.c scan5.c input*
  #+end_example
  Output:
  #+begin_example
  adding: scan1.cc (deflated 45%)
  adding: scan2.cc (deflated 48%)
  adding: scan3.cc (deflated 46%)
  adding: scan4.cc (deflated 52%)
  adding: scan5.cc (deflated 52%)
  adding: input1 (stored 0%)
  adding: input3 (stored 0%)
  adding: input4 (stored 0%)
  #+end_example

- You can look at the ZIP file with the command (finish by typing =q=):
  #+begin_example sh
    less sample.zip
  #+end_example

- This is what you should see:
  #+begin_example sh
    Archive:  scan.zip
   Length   Method    Size  Cmpr    Date    Time   CRC-32   Name
  --------  ------  ------- ---- ---------- ----- --------  ----
       604  Defl:N      330  45% 2025-02-14 22:54 e6455822  scan1.c
       562  Defl:N      291  48% 2025-02-15 01:53 2b9455cf  scan2.c
       509  Defl:N      277  46% 2025-02-15 01:56 1f557e2e  scan3.c
       709  Defl:N      339  52% 2025-02-15 18:11 d3d7ec6e  scan4.c
       698  Defl:N      338  52% 2025-02-15 18:17 84488150  scan5.c
        23  Stored       23   0% 2025-02-14 22:52 11044f8e  input1
        13  Stored       13   0% 2025-02-15 01:58 7e27c2c3  input3
         9  Stored        9   0% 2025-02-15 18:11 ae26204d  input4
  --------          -------  ---                            -------
     68736            12091  82%                            14 files
  scan.zip (END)
  #+end_example

- Upload the archive file =scan.zip= to Canvas!

* Footnotes

[fn:1]This should really work inside Emacs, too - in a ~bash~ or ~sh~ code
block provided that you have one of these programs installed (e.g. via
Cygwin or MSYS2). But Windows puts a weird symbol at the end of the
filename so that it cannot be read. The ~cat~ command works with ~input*~
but the ~:cmdline < input~ command in the Org-mode code block header
does not, alas.

[fn:2]After reading the first integer, =scanf= expects to find a ~/~
character immediately. It encounters a whitespace character instead,
which is not skipped because the whitespace is not leading (from
scanf's perspective at this point; it's looking for a specific
non-whitespace character, ~"/"~, and aborts.

[fn:3]The correct format specifier is: ="|%d|%d|%.3f|%.0f|\n"=.
